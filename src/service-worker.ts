/// <reference lib="webworker" />
/// <reference types="@sveltejs/kit" />

import { build, files, version } from '$service-worker';

const worker = self as unknown as ServiceWorkerGlobalScope;
const CACHE_NAME = `offline-cache-v${version}`;

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = [...build, ...files];
const staticAssets = new Set(to_cache);

console.log(files);

worker.addEventListener('install', (event) => {
	event.waitUntil(
		caches
			.open(CACHE_NAME)
			.then((cache) => cache.addAll(to_cache))
			.then(() => {
				worker.skipWaiting();
			})
	);
});

worker.addEventListener('activate', (event) => {
	event.waitUntil(
		caches.keys().then(async (keys) => {
			// delete old caches
			for (const key of keys) {
				if (key !== CACHE_NAME) await caches.delete(key);
			}

			worker.clients.claim();
		})
	);
});

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 */
async function fetchAndCache(request: Request) {
	const cache = await caches.open(CACHE_NAME);
	if (to_cache.includes(request.url)) {
		return cache.match(request);
	}

	try {
		const response = await fetch(request);
		if (response.status === 200) {
			cache.put(request, response.clone());
		}
		return response;
	} catch (err) {
		const response = await cache.match(request);
		if (response) return response;

		// Optionally provide a fallback page here
		// Example: return cache.match('/offline.html');
		// return cache.match(request);
		throw err;
	}
}

worker.addEventListener('fetch', (event) => {
	if (event.request.headers.get('range')) {
		const pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);
		console.log('Range request for', event.request.url, ', starting position:', pos);
		event.respondWith(
			caches
				.open(CACHE_NAME)
				.then(function (cache) {
					return cache.match(event.request.url);
				})
				.then(function (res) {
					if (!res) {
						return fetch(event.request).then((res) => {
							return res.arrayBuffer();
						});
					}
					return res.arrayBuffer();
				})
				.then(function (ab) {
					return new Response(ab.slice(pos), {
						status: 206,
						statusText: 'Partial Content',
						headers: [
							// ['Content-Type', 'video/webm'],
							['Content-Range', 'bytes ' + pos + '-' + (ab.byteLength - 1) + '/' + ab.byteLength]
						]
					});
				})
		);
	} else {
		console.log('Non-range request for', event.request.url);
		event.respondWith(
			// caches.match() will look for a cache entry in all of the caches available to the service worker.
			// It's an alternative to first opening a specific named cache and then matching on that.
			caches.match(event.request).then(function (response) {
				if (response) {
					console.log('Found response in cache:', response);
					return response;
				}
				console.log('No response found in cache. About to fetch from network...');
				// event.request will always have the proper mode set ('cors, 'no-cors', etc.) so we don't
				// have to hardcode 'no-cors' like we do when fetch()ing in the install handler.
				return fetch(event.request)
					.then(function (response) {
						console.log('Response from network is:', response);

						return response;
					})
					.catch(function (error) {
						// This catch() will handle exceptions thrown from the fetch() operation.
						// Note that a HTTP error response (e.g. 404) will NOT trigger an exception.
						// It will return a normal response object that has the appropriate error code set.
						console.error('Fetching failed:', error);

						throw error;
					});
			})
		);
	}
});
